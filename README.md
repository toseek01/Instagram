**Abstract**

Если вы читаете эту аннотацию, значит вы столкнулись с проблемой рассчета аттрибуции. Алгоритмов аттрибуции разнообразное множество , но данная документация описывает работу лишь с одним из них - Shapley Value Attribution algorithm. (далее просто Shapley).В этой документации мы постараемся максимально детально описать все шаги и методы расчетов Shapley.</br>
Для улучшения вашего понимания мы постараемся все абстрактные термины и сущности подкреплять наглядными иллюстрациями и всевозможными упрощения для достижения максимального понимания.

По возможносчти мы будем максимально избегать сложных и путанных математических терминов ,чтобы даже те из вас кто не дружит с математикой смогли сформировать у себя в голове ясную картину происходящего.</br>
Конечно же для людей знакомых с линейная алгеброй и математикой, желающих копать глубже и разобраться во всем досконально ,мы обязательно прикрепим ссылки на математические работы где вы сможете найти ответы на все технические и математические подводные камни, с которыми вы столкнетесь при работе с Shapley.

Все вычисления Shapley  построены основываясь на упрощенной версии алгоритма ("упрощенной"-не значит плохо/хуже ,
"упрощенной" - значит та же точность ,тот же функционал ,только быстрее и понятнее). Ссылки на все матриалы по старой доброй традиции ищите в конце документации.



**Introduction**

`r/zoomertimeforlearning`

Сразу позволим себе оговорится и прояснить для себя и для Вас ,какие задачи/цели не стоят перед этой документаций.
  - Как работает Shapley .Мы не ставим перед собой задачи детально донести до читателя все тонкости и нюансы
    устройства работы алгоритма.В конце документации мы обязательно прикрепим ссылки на очень полезные ресурсы благодаря которым ,
    Вы дорогой читатель, сможете погрузится во все математические и технические подробности Shapley. Если вы первый
    раз слышите про такой алгоритм, то советуем вам сначала прочитать теоретические доки , понять и ~~простить~~ осмыслить материал,
    и потом уже смело врываться в нашу документацию
  - Как устроена теория вероятностей, "почему это выржаение равно вот этому",теория множеств,линейнай алгебра и прочая математическая
    дичь. Наши возможности ограничены , у вас тоже мало времени , и мы в вас это ценим , но попутно описывать весь математический подвал
    у нас просто не хватит сил (+ r/bonusmyfriend ).В сети огромное количество литературы и ресурсов которые в случае чего (формула,
    символ, равенство) смогут до вас донести суть всего этого заумного безобразия

Теперь ,к тому чему вы научитесь прочитав эту документаци.

  - Быстро расчитывать аттрибутированные веса для каждого канала
  - Понять аттрибутированный вес каждой позиции (порядковый нормер места в цепях в которых находился канал) внутри каждого канала
  - Проверять ,правильно ли рассчитаны все аттрибутированные веса
  - Как строятся матрицы для быстрых расчетов аттрибуции и где их можно использовать в дальнейшем для решения уже `custom tasks`
  - Как расчитывать Shapley для лояльной/нелояльной аудитории и вообще что такой с точки зрения Shapley лояльная аудитория
  
**Contents**


* 1.1 *Theory Shapley Quick Start*</br>
* 1.2  *shapelyLib methods*</br>
* 1.3  *What is it "Shapley properties" and why we need to check shapleyLib result*</br>

* 2.1  *Theory Ordered Shapley Quick start*</br>
* 2.2. *shapleyOrderLib methods*</br>
* 2.3  *How to use shapleyOrderLib*</br>


***1.1 Theory Shapley Quick Start***

В этой главе мы не будем разбирать как устроен Shapley ,как он работает и что там под "капотом".Мы лишь дадим определения
некоторому набору математических понятий ,чтобы в дальнейшем опираясь на этот глоассарий мы могли бы понимать друг друга без каких либо весомых издержек.

***P** - Великая коалиция. Множество состоящее из рекламных каналов {X1, X2, . . . , Xp}</br>
***S*** - коалиция. Множество каналов из P</br>
***M(j,S)*** - Маржинальный вклад. UserID которые посетили канал Xj + S (в том числе и нулевое множество) и совершили некий вклад</br>
![Image alt](https://github.com/toseek01/Instagram/blob/master/illustration/marg.png)</br>
***Shapley algorithm*** - Формула расчета аттрибуции для всех каналов (Shapley attribution formula)</br>
![Image alt](https://github.com/toseek01/Instagram/blob/master/illustration/shp.png)</br>
Где R(S U {Xj}) указывает на маржинальный вклад UserID, которые посетили **ВСЕ** каналы внутри коалиции S U {Xj}.</br>
***Фj***- Аттрибутированный вес канала (Shapley value)</br>
***total campaign*** - Сумма конверсий за всю кампанию</br>
***Shapley values*** - Аттрибутированные веса каналов ,после их прохождения через **Shapley algorithm***</br>


**1.2 shapelyLib methods**

shapelyLib состоит всего из 10 методов, и в этой главе мы постараемся объяснить, основываясь на какой логике работает каждый из них.
Рассмотрим в какой последовательности их следует применять,какой метод за что отвечает,имеет ли он альтернативу внутри класса а так же какие данные (тип,формат и прочее) следует подавать на вход для каждого из них. 
И конечно же что мы ожидаем получить на выходе у каждогио из этих методов.

![Image alt](https://github.com/toseek01/Instagram/blob/master/illustration/LetsGo_Technik.png)

Итак,имеем следующие методы:
- `__init__`
- `UniqueChainCheck`
- `ChainSplit`
- `ChannelDict`
- `UniqueChannel`
- `ChanneltoID`
- `ZeroMatrix`
- `Vectorization`
- `Calc`
- `DecodeDict`
Здесь мы не будем разбирать какие переменные в каком методе за что отвечают - это прекрасно сделано в комментариях к самому коду, такая сказать вторая документация ,но только уже внутри кода)

**__init__**

Здесь хранятся все стратегически важные переменные для внутренних расчетов Shapley и формирования алгебраических сущностей,кодировки каналов,режимы расчетов и тд. Обо всем подробно будет изложено ниже. 

`args`
- data.Аггрегированные данные (pandas) ,строящиеся на основе DMP и/или Google Analytics.Собой эти данные представляют аггрегированные пути пользователей(userID) и соответствующие им конверсии, которые эти пользователи совершили ,перемещаясь по этим цепочкам.
Пример:</br>
a->b->d 10</br>
c->c->d 4</br>
a->a->e 8</br>
b->a->b 3</br>
d->e->b 6</br>

Цепочки могут быть разной длины,содержать сколько угодно каналов ,а также сколько угодно повторяющихся каналов внутри одной цепи.Главное требование к цепочкам, это то ,чтобы все они были *уникальными*.
Конверсии должны иметь тип Int или Float.

- channel_delimiter. Разделитель csv файла ,по дефолту стоит
- loyal. Аргумент loyal является режимом условной лояльности. Проще говоря это сколько контактов с рекламой у пользователей должно было произойти прежде чем они совершили конверсию.Пусть лояльными userID мы будем считать людей кто имел не более N контактов с рекламой, после которых они совершили конверсию. Благодаря этому режиму ,мы можем смотреть как изменятся Shapley values у нелояльной аудитории по отношению к лояльной.Режим имеет только два значения - True и False
- loyal_position. Количество контактов с рекламой для определения лояльной аудитории.Только если loyal==True

**UniqueChainCheck** Проверяет уникальность цепей в *data*. Если будут обнаружены дубликаты, вычисления останавливаются и выдается ошибка</br>

**ChainSplit** Разбивает последовательность каналов (строку) на каналы . Пример: a->b->c => [a,b,c]</br>

**ChannelDict** Словарь для хранения уникального ID для каждого канала</br>

**UniqueChannel** Считает количество уцикальных каналов во всех цепях ,а также создает список этих уникальных каналов</br>

**ChanneltoID** Конвертирует канал(название канала String) в его ID ,которое было создано и хранится в ранее указанном `ChannelDict`</br>

**ZeroMatrix** Создает матрицу размером (кол-во цепей Х кол-во уникальных каналов).В дальнейшем на основе этой матрицы будет рассчитываться Shapley</br>

**Vectorization** Правильно заполняет матрицу созданную `ZeroMatrix` методом</br>

**DecodeDict** Декодирует shapley_dict {channelID:shapley_value} в понятный словарь {channel_name:shapley_value}</br>

**1.3 What is it "Shapley properties" and why we need to check shapleyLib result**

Когда мы при помощи класса shapleyLib получили значения аттрибутированных каналов , встает вопрос - А корректно ли все рассчитал алгоритм, нет ли там какой нибудь ошибки.Для того чтобы это понять мы должны прогнать наши полученные значения через определенные свойства (необходимые равенства) Shapley ,чтобы убедиться на все 100% ,что полученные нами результаты верны

За проверку результатов и свойств отвечает класс ***Properties***

- ***Efficiency***
![Image alt](https://github.com/toseek01/Instagram/blob/master/illustration/efficiency.png)</br>
Это свойство помогает нам убедиться что сумма всех Shapley values (аттрибутированных весов) равна сумме всех конверсий кампании.За проверку этого свойства отвечает метод `Efficiency`.</br>
Если условие соблюдено - возвращает True

- ***DummyPlayer***
Если канал Xj такой ,что M(j,S) = 0 для каждой коалиции S не содержащей Xj ,тогда 
![Image alt](https://github.com/toseek01/Instagram/blob/master/illustration/dummy.png)</br>
Канал ,который не внес никакого вклада ни в одну из коалиций будет иметь нулевой вес.
За проверку этого свойства отвечает метод `DummyPlater`.</br>
Если условие соблюдено - возвращает True</br>
`Properties` следует обязательно использовать после каждого расчета Shapley !</br>

Что метод `Efficiency` ,что метод `DummyPlayer` принимают на вход 2 одинаковых параметра : `Shapley values` и `total campaign` .

**2.1 Theory Ordered Shapley Quick start**

Важная проблема Shapley в том, что алгоритм игнорирует специфичность путей UserID, которые совершили конверсии. Алгоритм
не делает никакого разделения был ли канал на первом месте или последнем,полностью игнорирует последовательность каналов и их места в цепи. Позиция канала в цепи никаким образом не повлияет на итоговый аттрибутированный вес этого канала. Задача Ordered Shapley Algorithm (далее Ordered Shapley) состоит в том,чтобы устранить этот недостаток и попытаться ответить на вопрос, как же распределялся вес каждой позиции в цепочке внутри канала</br>
Для каждого Xj канала и коалиции 𝑆 ∈ 𝑃\{Xj} ,UserID которые внесли вклад 𝑅(𝑆 ∪ {Xj}, могли посещать каналы в коалиции 𝑆 ∪ {Xj} в разном порядке. В дальнецшем мы будем различать ,основываясь на позиции канала Xj в цепи.
Ri(S U {Xj}) - вклад всех UserID ,кто посетил Xj канал на i-ой позиции.i ∈  {1, 2, … , 𝑁} ,где N кол-во каналов в самой длинной цепи.</br> 
![Image alt](https://github.com/toseek01/Instagram/blob/master/illustration/ordermarg.png)</br>

Тогда логично,что Ordered Shapley для каждого канала и каждой его позиции рассчитывается по следующей формуле</br>
![Image alt](https://github.com/toseek01/Instagram/blob/master/illustration/shaporder.png)</br>

**2.2.shapleyOrderLib methods**


Итак,имеем следующие методы:
- `__init__`
- `CreditChannel`
- `VectorizationOrder`
- `MatrixOrder`
- `Cardinality`
- `TouchpointR`
- `Calc`
Еще раз повторимся - здесь мы не будем разбирать какие переменные в каком методе за что отвечают - это прекрасно сделано в комментариях к самому коду, такая сказать вторая документация ,но только уже внутри кода)

***__init__***
На всход подается shapley class ,который использовался для хранения и расчетов Shapley values</br>
***CreditChannel*** Оставляет только каналы с shapley value > 0 ,чтобы Ordered Shapley не тратил время на расчетов весов позиций для каналов чей вес равен 0</br>

***VectorizationOrder*** Конвертирует цепочку в вектор ,содержищий их ID .Пример:</br>
a->b->c->d => [a_id,b_id,c_id,d_id].</br>
Вторая функция этого метода это выявление и расчет  максимальной длины цепочки в множестве всех цепей</br>

***MatrixOrder*** По сути ,этот метод выполняет аналогичные операции что и модуль</br>

**Vectorization** в классе `shapleyLib`, а именно формирует матрицу расчетов для Shapley, с той лишь разницей что в этой матрице будут учитываться знания и кол-ве наличия данного канала в конкретной цепи</br>

***Cardinality*** Расчет мощности множества (см теорию "How to calculate cardinality of set")</br> 

***TouchpointR*** Рассчитывает веса каждой позиции внутри одного канала</br> 

***Calc*** Запускает Order Shapley</br> 

